foldl1 (+) $ map (\x -> read [x] :: Int) $ show 1234
1 + 1
foldl1 (+) $ map (\x -> read [x] :: Int) $ show 1234
foldl1 (+) $ map (\x -> read [x] :: Int) $ show 1234
map (\x -> read [x] :: Int) $ show 1234
map (\x -> read [x] :: Int) (show 1234)
map (\x -> read x :: Int) (show 1234)
map (\x -> read x :: Int) $ show 1234
:t splitAt 
splitAt "," "abc"
split "," $ intersperse "," $ show 1234
show 1234
"" + 1234
let n = 1234
isSmith 6
isSmith 5
isSmith 4
isSmith 3
isSmith 2
isSmith 1
isSmith 0
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
isSmith 0
isSmith 26
isSmith 22
isSmith 50
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
null [1]
null []
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
isSmith 1
isSmith 1
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
foldl1 (+) $ map sumDigits $ factors (37 * 2)
reduce (+) $ map sumDigits $ factors (37 * 2)
map sumDigits $ factors (37 * 2)
map sumDigits $ factors (37*2)
map sumDigits $ factors 37*2
map sumDigits $ factors 1584
map sumDigits $ factors 1
foldl1 sumDigits $ factors 1
let isSmith n = sumDigits n == foldl1 sumDigits $ factors n
:l Spec.hs 
factors 1584
:l Spec.hs 
factors 1584
:l Spec.hs 
:l Spec.hs 
factors' 1584 []
factors' 777 []
factors' 734567777 []
factors' 73456 []
factors' 280 []
factors' 80 []
factors' 40 []
factors' 40 [4]
factors' 40 []
:l Spec.hs 
:l Spec.hs 
factors' 40 []
:l Spec.hs 
factors' 40 []
factors' 5 []
factors' 5
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
foldl1 (*) [2,3]
foldl1 [2,3] (*)
foldl1 [2,3] *
factors 56
factors 5
:l Spec.hs 
:l Spec.hs 
:k Integral 
:t Integral 
Integral
Integral 1
Integral:: 1
Integral 1
